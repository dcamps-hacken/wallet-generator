{
  "language": "Solidity",
  "sources": {
    "contracts/DestroyableWallet.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.7;\r\n\r\nerror DestroyableWallet__Unauthorized();\r\nerror DestroyableWallet__ClosedWallet();\r\nerror DestroyableWallet__StatusNotPreDestroy();\r\n\r\n/** @title EVM wallet\r\n *  @author David Camps Novi\r\n *  @dev This contract has some common functions used in a wallet\r\n */\r\ncontract DestroyableWallet {\r\n    enum WalletStatus {\r\n        CLOSED,\r\n        PREDESTROY,\r\n        OPEN\r\n    }\r\n\r\n    WalletStatus public s_status;\r\n\r\n    address private immutable i_owner;\r\n\r\n    event FundsReceived(address indexed sender, uint256 amount);\r\n    event FundsTransfer(address indexed recipient, uint256 amount);\r\n    event AllWithdraw(uint256 _amount);\r\n    event WalletDelete(address recipient, uint256 amount);\r\n\r\n    modifier onlyOwner() {\r\n        if (msg.sender != i_owner) revert DestroyableWallet__Unauthorized();\r\n        _;\r\n    }\r\n\r\n    modifier walletOpen() {\r\n        if (s_status != WalletStatus.OPEN)\r\n            revert DestroyableWallet__ClosedWallet();\r\n        _;\r\n    }\r\n\r\n    constructor(address _owner) {\r\n        i_owner = _owner;\r\n        s_status = WalletStatus.OPEN;\r\n    }\r\n\r\n    receive() external payable {\r\n        //msg.data is empty\r\n        if (s_status != WalletStatus.OPEN)\r\n            revert DestroyableWallet__ClosedWallet();\r\n        emit FundsReceived(msg.sender, msg.value);\r\n    }\r\n\r\n    fallback() external payable {\r\n        //msg.data is not empty\r\n        if (s_status != WalletStatus.OPEN)\r\n            revert DestroyableWallet__ClosedWallet();\r\n        emit FundsReceived(msg.sender, msg.value);\r\n    }\r\n\r\n    /**\r\n     *  @notice This function transfers some funds from this wallet to another address.\r\n     */\r\n    function transferFunds(uint256 _amount, address _recipient)\r\n        external\r\n        onlyOwner\r\n    {\r\n        payable(_recipient).transfer(_amount);\r\n        emit FundsTransfer(_recipient, _amount);\r\n    }\r\n\r\n    /**\r\n     *  @notice This function withdraws the whole balance of this wallet to the address\r\n     *  that deployed it.\r\n     */\r\n    function withdrawAll(uint256 _amount) external onlyOwner {\r\n        payable(msg.sender).transfer(address(this).balance);\r\n        emit AllWithdraw(_amount);\r\n    }\r\n\r\n    /**\r\n     *  @notice This wallet comes with a selfdestruct functionality. In order to add extra\r\n     *  protection, this is a two-step process: first call preDestroy(), then deleteWallet().\r\n     *  Use the function cancelPreDestroy() if you want to restore the wallet to the previous\r\n     *  status. Once the wallet is destroyed, all its funds will be send to a given address and\r\n     *  the wallet will become inoperative.\r\n     *  @dev To control the status of the wallet, an enum \"status\" has been generated. The\r\n     *  function deleteWallet() can only be called if the status is PREDESTROY. The status\r\n     *  of the wallet can be checked with the function getStatus().\r\n     *  @param _recipient Is the address to which the funds of this wallet will be sent.\r\n     */\r\n    function destroyWallet(address _recipient) external onlyOwner walletOpen {\r\n        if (s_status != WalletStatus.PREDESTROY)\r\n            revert DestroyableWallet__StatusNotPreDestroy();\r\n        emit WalletDelete(_recipient, address(this).balance);\r\n        selfdestruct(payable(_recipient));\r\n    }\r\n\r\n    function preDestroy() external onlyOwner {\r\n        s_status = WalletStatus.PREDESTROY;\r\n    }\r\n\r\n    function cancelPreDestroy() external onlyOwner {\r\n        s_status = WalletStatus.OPEN;\r\n    }\r\n\r\n    /**\r\n     *  @notice This function returns the address of your address.\r\n     */\r\n    function getBalance() external view returns (uint256) {\r\n        return (address(this).balance);\r\n    }\r\n\r\n    /**\r\n     *  @dev This function will return '2' if the wallet is in its steady state and '1'\r\n     *  if it's in PREDESTROY status.\r\n     */\r\n    function getStatus() external view returns (WalletStatus) {\r\n        return s_status;\r\n    }\r\n}\r\n"
    },
    "contracts/WalletGenerator.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.7;\r\n\r\nimport \"./SimpleWallet.sol\";\r\nimport \"./DestroyableWallet.sol\";\r\nimport \"./MultisigWallet.sol\";\r\n\r\n/** @title EVM wallet generator\r\n *  @author David Camps Novi\r\n *  @dev This contract uses a factory pattern to deploy a new wallet for each user\r\n */\r\ncontract WalletGenerator {\r\n    mapping(address => mapping(uint256 => address)) private s_wallets;\r\n    /* Number of Wallets created by each User */\r\n    mapping(address => uint256) s_numberOfWallets;\r\n\r\n    event WalletCreate(\r\n        address indexed owner,\r\n        address indexed walletAddress,\r\n        string walletType\r\n    );\r\n\r\n    /**\r\n     *  @notice This is the function that will deploy a new wallet every time it's called.\r\n     *  @dev The wallet addresses and Ids are stored in mappings so that users can get\r\n     *  their wallet addresses.\r\n     */\r\n    function createSimpleWallet() external {\r\n        SimpleWallet newWallet = new SimpleWallet(msg.sender);\r\n        uint256 nextWalletId = s_numberOfWallets[msg.sender];\r\n        s_wallets[msg.sender][nextWalletId] = address(newWallet);\r\n        s_numberOfWallets[msg.sender] += 1;\r\n        emit WalletCreate(msg.sender, address(newWallet), \"SimpleWallet\");\r\n    }\r\n\r\n    function createDestroyableWallet() external {\r\n        DestroyableWallet newWallet = new DestroyableWallet(msg.sender);\r\n        uint256 nextWalletId = s_numberOfWallets[msg.sender];\r\n        s_wallets[msg.sender][nextWalletId] = address(newWallet);\r\n        s_numberOfWallets[msg.sender] += 1;\r\n        emit WalletCreate(msg.sender, address(newWallet), \"DestroyableWallet\");\r\n    }\r\n\r\n    function createMultisigWallet(\r\n        address[] memory _owners,\r\n        uint256 _requiredConfirmations\r\n    ) external {\r\n        MultisigWallet newWallet = new MultisigWallet(\r\n            _owners,\r\n            _requiredConfirmations\r\n        );\r\n        uint256 nextWalletId = s_numberOfWallets[msg.sender];\r\n        s_wallets[msg.sender][nextWalletId] = address(newWallet);\r\n        s_numberOfWallets[msg.sender] += 1;\r\n        emit WalletCreate(msg.sender, address(newWallet), \"MultisigWallet\");\r\n    }\r\n\r\n    /**\r\n     *  @notice Use this function to get the address of your last created wallet\r\n     */\r\n    function getLatestWallet() external view returns (address) {\r\n        uint256 latestId = s_numberOfWallets[msg.sender];\r\n        return s_wallets[msg.sender][latestId];\r\n    }\r\n\r\n    function getWalletFromId(uint256 _Id) external view returns (address) {\r\n        return s_wallets[msg.sender][_Id];\r\n    }\r\n\r\n    function getAllWallets() external view returns (address[] memory) {\r\n        address[] memory addresses;\r\n        for (uint256 i; i < s_numberOfWallets[msg.sender]; i++) {\r\n            addresses[i] = s_wallets[msg.sender][i];\r\n        }\r\n        return addresses;\r\n    }\r\n}\r\n"
    },
    "contracts/SimpleWallet.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.7;\r\n\r\nerror SimpleWallet__Unauthorized();\r\n\r\n/** @title EVM wallet\r\n *  @author David Camps Novi\r\n *  @dev This contract has some common functions used in a wallet\r\n */\r\ncontract SimpleWallet {\r\n    address private immutable i_owner;\r\n\r\n    event FundsReceived(address indexed sender, uint256 amount);\r\n    event FundsTransfer(address indexed recipient, uint256 amount);\r\n    event AllWithdraw(uint256 _amount);\r\n    event WalletDelete(address recipient, uint256 amount);\r\n\r\n    modifier onlyOwner() {\r\n        if (msg.sender != i_owner) revert SimpleWallet__Unauthorized();\r\n        _;\r\n    }\r\n\r\n    constructor(address _owner) {\r\n        i_owner = _owner;\r\n    }\r\n\r\n    receive() external payable {\r\n        emit FundsReceived(msg.sender, msg.value);\r\n    }\r\n\r\n    fallback() external payable {\r\n        emit FundsReceived(msg.sender, msg.value);\r\n    }\r\n\r\n    /**\r\n     *  @notice This function transfers some funds from this wallet to another address.\r\n     */\r\n    function transferFunds(uint256 _amount, address _recipient)\r\n        external\r\n        onlyOwner\r\n    {\r\n        payable(_recipient).transfer(_amount);\r\n        emit FundsTransfer(_recipient, _amount);\r\n    }\r\n\r\n    /**\r\n     *  @notice This function withdraws the whole balance of this wallet to the address\r\n     *  that deployed it.\r\n     */\r\n    function withdrawAll(uint256 _amount) external onlyOwner {\r\n        payable(msg.sender).transfer(address(this).balance);\r\n        emit AllWithdraw(_amount);\r\n    }\r\n\r\n    /**\r\n     *  @notice This function returns the address of your address.\r\n     */\r\n    function getBalance() external view returns (uint256) {\r\n        return (address(this).balance);\r\n    }\r\n}\r\n"
    },
    "contracts/MultisigWallet.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.7;\r\n\r\nerror MultisigWallet__Unauthorized();\r\nerror MultisigWallet__AlreadyApproved();\r\nerror MultisigWallet_NotEnoughConfirmations();\r\n\r\ncontract MultisigWallet {\r\n    struct Tx {\r\n        uint256 amount;\r\n        address recipient;\r\n        uint256 confirmations;\r\n        bool executed;\r\n    }\r\n\r\n    uint256 private nextTxId;\r\n    uint256 private requiredConfirmations;\r\n    mapping(uint256 => Tx) private s_txs;\r\n    mapping(address => bool) private s_owners;\r\n    mapping(uint256 => mapping(address => bool)) s_approvals;\r\n\r\n    event FundsReceived(address indexed sender, uint256 amount);\r\n    event TxSubmit(uint256 txId, address requester);\r\n    event TxApprove(uint256 txId, address approver);\r\n    event TxSend(uint256 txId, address sender);\r\n\r\n    modifier onlyOwners() {\r\n        if (s_owners[msg.sender] != true) revert MultisigWallet__Unauthorized();\r\n        _;\r\n    }\r\n\r\n    constructor(address[] memory _owners, uint256 _requiredConfirmations) {\r\n        for (uint256 i; i < _owners.length; i++) {\r\n            s_owners[_owners[i]] = true;\r\n        }\r\n        requiredConfirmations = _requiredConfirmations;\r\n    }\r\n\r\n    receive() external payable {\r\n        emit FundsReceived(msg.sender, msg.value);\r\n    }\r\n\r\n    fallback() external payable {\r\n        emit FundsReceived(msg.sender, msg.value);\r\n    }\r\n\r\n    function submitTx(uint256 _amount, address _recipient) external onlyOwners {\r\n        s_txs[nextTxId] = Tx({\r\n            amount: _amount,\r\n            recipient: _recipient,\r\n            confirmations: 1,\r\n            executed: false\r\n        });\r\n        s_approvals[nextTxId][msg.sender] = true;\r\n        emit TxSubmit(nextTxId, msg.sender);\r\n        nextTxId += 1;\r\n    }\r\n\r\n    function approveTx(uint256 _txId) external onlyOwners {\r\n        if (s_approvals[_txId][msg.sender] != false)\r\n            revert MultisigWallet__AlreadyApproved();\r\n        s_txs[_txId].confirmations += 1;\r\n        emit TxApprove(_txId, msg.sender);\r\n    }\r\n\r\n    function sendTx(uint256 _txId) external onlyOwners {\r\n        if (s_txs[_txId].confirmations < requiredConfirmations)\r\n            revert MultisigWallet_NotEnoughConfirmations();\r\n        address payable recipient = payable(s_txs[_txId].recipient);\r\n        uint256 amount = s_txs[_txId].amount;\r\n        recipient.transfer(amount);\r\n        emit TxSend(_txId, msg.sender);\r\n    }\r\n\r\n    function addOwner(address _newOwner) external onlyOwners {\r\n        s_owners[_newOwner] = true;\r\n    }\r\n\r\n    function removeOwner(address _newOwner) external onlyOwners {\r\n        s_owners[_newOwner] = false;\r\n    }\r\n\r\n    function changeConfirmations(uint256 _newConfirmations) external {\r\n        requiredConfirmations = _newConfirmations;\r\n    }\r\n\r\n    function getBalance() external view returns (uint256) {\r\n        return (address(this).balance);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}